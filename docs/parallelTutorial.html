<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>From scripts to GNU Parallel &#8212; Multijob 0.0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="multijob.job module" href="api/multijob.job.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="from-scripts-to-gnu-parallel">
<h1>From scripts to GNU Parallel<a class="headerlink" href="#from-scripts-to-gnu-parallel" title="Permalink to this headline">¶</a></h1>
<p>This tutorial describes in more detail how you can run jobs with GNU Parallel by using the <a class="reference internal" href="api/multijob.commandline.html#module-multijob.commandline" title="multijob.commandline"><code class="xref py py-mod docutils literal"><span class="pre">multijob.commandline</span></code></a> module.</p>
<p>Prerequisites:</p>
<ul class="simple">
<li>You can generate job configurations with <a class="reference internal" href="api/multijob.job.html#multijob.job.JobBuilder" title="multijob.job.JobBuilder"><code class="xref py py-class docutils literal"><span class="pre">multijob.job.JobBuilder</span></code></a>.</li>
<li>You can run <a class="reference internal" href="api/multijob.job.html#multijob.job.Job" title="multijob.job.Job"><code class="xref py py-class docutils literal"><span class="pre">Job</span></code></a>s and can deal with <a class="reference internal" href="api/multijob.job.html#multijob.job.JobResult" title="multijob.job.JobResult"><code class="xref py py-class docutils literal"><span class="pre">JobResult</span></code></a>s.</li>
<li>You are comfortable with the Linux shell.</li>
</ul>
<div class="section" id="concepts-and-architecture">
<h2>Concepts and Architecture<a class="headerlink" href="#concepts-and-architecture" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="api/multijob.html#module-multijob" title="multijob"><code class="xref py py-mod docutils literal"><span class="pre">multijob</span></code></a> module is intended to support
easy parallelization of computation-intensive jobs,
for example: evolutionary algorithms.
We assume all jobs are the same
but are executed with different parameter values.</p>
<p>For the purpose of this tutorial, we will assume the EA is written in Python.
However, the command line interface is language-agnostic and can also be adapted for other languages.</p>
<p>The central part of your work is the executable that performs the job.
I&#8217;ll call it <code class="docutils literal"><span class="pre">runGA.py</span></code>.
This executable will be invoked with the job parameters as command line parameters.
The command line parameters are represented in our code as <a class="reference internal" href="api/multijob.job.html#multijob.job.Job" title="multijob.job.Job"><code class="xref py py-class docutils literal"><span class="pre">multijob.job.Job</span></code></a> objects.</p>
<p>The general workflow is:</p>
<ol class="arabic simple">
<li>Generate a list of job configurations with the <a class="reference internal" href="api/multijob.job.html#multijob.job.JobBuilder" title="multijob.job.JobBuilder"><code class="xref py py-class docutils literal"><span class="pre">multijob.job.JobBuilder</span></code></a>.</li>
<li>Turn the list into a shell script with <a class="reference internal" href="api/multijob.commandline.html#multijob.commandline.shell_command_from_job" title="multijob.commandline.shell_command_from_job"><code class="xref py py-func docutils literal"><span class="pre">multijob.commandline.shell_command_from_job()</span></code></a>.
This shell script can be seen as a job queue.</li>
<li>Process the job queue with GNU Parallel.
This will invoke the <code class="docutils literal"><span class="pre">runGA.py</span></code> program.
The actual target program may be run locally, or on a remote server.</li>
<li>In the <code class="docutils literal"><span class="pre">runGA.py</span></code>, decode the command line arguments back to a Job instance.</li>
<li>In the <code class="docutils literal"><span class="pre">runGA.py</span></code>, execute the Job</li>
<li>In the <code class="docutils literal"><span class="pre">runGA.py</span></code>, write the results to output files.</li>
<li>Aggregate and analyze your results.</li>
</ol>
</div>
<div class="section" id="typemaps-and-coercions">
<h2>Typemaps and Coercions<a class="headerlink" href="#typemaps-and-coercions" title="Permalink to this headline">¶</a></h2>
<p>To convert between <a class="reference internal" href="api/multijob.job.html#multijob.job.Job" title="multijob.job.Job"><code class="xref py py-class docutils literal"><span class="pre">multijob.job.Job</span></code></a> instances and command line parameters, we need to <em>coerce</em> each parameter value.
A <a class="reference internal" href="api/multijob.commandline.html#multijob.commandline.Coercion" title="multijob.commandline.Coercion"><code class="xref py py-class docutils literal"><span class="pre">Coercion</span></code></a> is a function that specifies how this is done.
A mapping between parameter names and the coercions that should be used for these parameters is a <em>typemap</em>.</p>
<p>When converting a job to the command line params, by default we convert each parameter with <code class="docutils literal"><span class="pre">str()</span></code>.
This works fine for strings, numbers, booleans, etc.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multijob.job</span> <span class="k">import</span> <span class="n">JobBuilder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multijob.commandline</span> <span class="k">import</span> <span class="n">shell_command_from_job</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">dummy_target</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">job</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">JobBuilder</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">42.3</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">dummy_target</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">shell_command_from_job</span><span class="p">(</span><span class="s1">&#39;runGA.py&#39;</span><span class="p">,</span> <span class="n">job</span><span class="p">))</span>
<span class="go">runGA.py --id=0 --rep=0 -- x=foo y=42.3 z=False</span>
</pre></div>
</div>
<p>If you want to pass special types that do not have a suitable string representation, you may have to write your own coercion.
E.g. if you want to pass a list of values for a parameter, we might want to encode it as CSV.
Note that we now declare a <code class="docutils literal"><span class="pre">TYPEMAP</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">csv</span><span class="o">,</span> <span class="nn">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multijob.job</span> <span class="k">import</span> <span class="n">JobBuilder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multijob.commandline</span> <span class="k">import</span> <span class="n">shell_command_from_job</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">dummy_target</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">as_csv_line</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">out</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TYPEMAP</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">xs</span><span class="o">=</span><span class="n">as_csv_line</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">job</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">JobBuilder</span><span class="p">(</span><span class="n">xs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Bond, James&#39;</span><span class="p">,</span> <span class="s1">&#39;007&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">dummy_target</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">shell_command_from_job</span><span class="p">(</span><span class="s1">&#39;runGA.py&#39;</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">typemap</span><span class="o">=</span><span class="n">TYPEMAP</span><span class="p">))</span>
<span class="go">runGA.py --id=0 --rep=0 -- &#39;xs=&quot;Bond, James&quot;,007&#39;</span>
</pre></div>
</div>
<p>This typemap just says:
“for the <code class="docutils literal"><span class="pre">xs</span></code> parameter, use the <code class="docutils literal"><span class="pre">as_csv_line()</span></code> function.”</p>
<p>On the other end, we have to turn the command line parameters back to into a Job instance.
This is usually a bit more difficult.
In particular, we will almost always need a typemap.
The coercions now specify how to turn the string back into a Python object.
For simple built-in types like strings, ints, floats, and bools, you can use the type name as a string in place of a coercion – a <em>named coercion</em>.
See the <a class="reference internal" href="api/multijob.commandline.html#multijob.commandline.Coercion" title="multijob.commandline.Coercion"><code class="xref py py-class docutils literal"><span class="pre">Coercion</span></code></a> docs for details.</p>
<p>In Python, the command line parameters can be read from the <code class="docutils literal"><span class="pre">sys.argv</span></code> list.
The first item is the name of the current command and has to be skipped.
Multijob provides the <code class="xref py py-func docutils literal"><span class="pre">multi.commandline.job_from_argv()</span></code> function for the conversion:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multijob.commandline</span> <span class="k">import</span> <span class="n">job_from_argv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_algorithm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>  <span class="c1"># you probably have something more interesting here</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">y</span> <span class="k">if</span> <span class="n">z</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TYPEMAP</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">x</span><span class="o">=</span><span class="s1">&#39;str&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">y</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">z</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># argv = sys.argv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">argv</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;runGA.py&#39;</span><span class="p">,</span> <span class="s1">&#39;--id=0&#39;</span><span class="p">,</span> <span class="s1">&#39;--rep=0&#39;</span><span class="p">,</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;x=foo&#39;</span><span class="p">,</span> <span class="s1">&#39;y=42.3&#39;</span><span class="p">,</span> <span class="s1">&#39;z=False&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># remember to skip first argv entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">job</span> <span class="o">=</span> <span class="n">job_from_argv</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">my_algorithm</span><span class="p">,</span> <span class="n">typemap</span><span class="o">=</span><span class="n">TYPEMAP</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># execute the job</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">result</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Instead of using the predefined named coercions, you can always provide your own functions.</p>
</div>
<div class="section" id="converting-a-runga-function-to-a-runga-py-script">
<h2>Converting a <code class="docutils literal"><span class="pre">runGA()</span></code> function to a <code class="docutils literal"><span class="pre">runGA.py</span></code> script<a class="headerlink" href="#converting-a-runga-function-to-a-runga-py-script" title="Permalink to this headline">¶</a></h2>
<p>When moving to Multijob, you don&#8217;t have to throw your existing code away:
Multijob is absolutely framework-agnostic.
We only need a function that takes all configuration parameters as (named) arguments.
So as long as you have such a <code class="docutils literal"><span class="pre">runGA()</span></code> function or can easily write one, everything is good.</p>
<p>In Python, it is possible to use a <code class="docutils literal"><span class="pre">.py</span></code> file as both a module that can be imported, and a script that can be executed directly.
Anything that should be only run for a script has to be guarded, since top-level code is executed even for modules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="c1"># always executed</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="o">...</span> <span class="c1"># only executed when used as a script</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">runGA()</span></code> function would be in the always-executed part.
Our adaption code will live in the guarded section.</p>
<div class="section" id="creating-a-typemap-to-decode-command-line-args">
<h3>Creating a Typemap to decode command line args<a class="headerlink" href="#creating-a-typemap-to-decode-command-line-args" title="Permalink to this headline">¶</a></h3>
<p>To adapt this function, we only have to decode the command line parameters.
As shown above, this requires a <em>typemap</em>.
We then get a <a class="reference internal" href="api/multijob.job.html#multijob.job.Job" title="multijob.job.Job"><code class="xref py py-class docutils literal"><span class="pre">Job</span></code></a> instance that can then be run.</p>
<p>To construct the typemap, we look at the parameters for the <code class="docutils literal"><span class="pre">runGA</span></code> function.
Usually, our typemap will have an entry for each named parameter.
Here is a simple case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">runGA</span><span class="p">(</span><span class="n">popsize</span><span class="p">,</span> <span class="n">cxpb</span><span class="p">,</span> <span class="n">mutpb</span><span class="p">,</span> <span class="n">use_injection</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>All parameters are named in the function definition, so we start writing our typemap:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">TYPEMAP</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">popsize</span><span class="o">=...</span><span class="p">,</span>
    <span class="n">cxpb</span><span class="o">=...</span><span class="p">,</span>
    <span class="n">mutpb</span><span class="o">=...</span><span class="p">,</span>
    <span class="n">use_injection</span><span class="o">=...</span><span class="p">)</span>
</pre></div>
</div>
<p>We now have to select the types for these parameters.
Note that the typemap does not contain classes or class names, but <em>coercion functions</em> that parse the parameter value from a string.
Some constructors (like <code class="xref py py-func docutils literal"><span class="pre">int()</span></code>) happen to correctly parse any string they are given.
For other constructors, this is not the case.
For example, <code class="docutils literal"><span class="pre">bool('False')</span> <span class="pre">==</span> <span class="pre">True</span></code>, so <code class="xref py py-func docutils literal"><span class="pre">bool()</span></code> <em>is not</em> a suitable coercion function.</p>
<p>To solve such problems, common conversions can simply be specified as <em>named coercions</em>. Here:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">TYPEMAP</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">popsize</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span>
    <span class="n">cxpb</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span>
    <span class="n">mutpb</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">,</span>
    <span class="n">use_injection</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Not all functions are so easy.
If the parameter list uses <code class="docutils literal"><span class="pre">**kwargs</span></code> to collect many named parameters, you&#8217;ll have to trace the code to find the actual parameter names.
If the parameter list slurps many <code class="docutils literal"><span class="pre">*args</span></code> into a list, you will have to provide a parameter called <code class="docutils literal"><span class="pre">args</span></code> in your TYPEMAP which then expects a list.
Remember that all parameters are passed as named parameters, not as positional parameters.</p>
</div>
<div class="section" id="decoding-and-running-the-job">
<h3>Decoding and running the Job<a class="headerlink" href="#decoding-and-running-the-job" title="Permalink to this headline">¶</a></h3>
<p>With the typemap, you can easily re-create a job from the command line arguments and execute it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">multijob.commandline</span> <span class="k">import</span> <span class="n">job_from_argv</span>

<span class="k">def</span> <span class="nf">runGA</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">TYPEMAP</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">,</span> <span class="n">b</span><span class="o">=...</span><span class="p">,</span> <span class="n">c</span><span class="o">=...</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">job_from_argv</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">runGA</span><span class="p">,</span> <span class="n">typemap</span><span class="o">=</span><span class="n">TYPEMAP</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Note that you have to skip the first command line parameter:
<code class="docutils literal"><span class="pre">sys.argv[0]</span></code> contains the name of the executable, not any real parameters.</p>
</div>
<div class="section" id="storing-results-in-a-file">
<h3>Storing results in a file<a class="headerlink" href="#storing-results-in-a-file" title="Permalink to this headline">¶</a></h3>
<p>After you executed the job,
the <a class="reference internal" href="api/multijob.job.html#multijob.job.JobResult" title="multijob.job.JobResult"><code class="xref py py-class docutils literal"><span class="pre">JobResult</span></code></a> should be stored somewhere.
It is best to use language-agnostic formats like CSV for this.</p>
<p>If you are storing the results in a file, you will of course need different file names for each parameter configuration.
The Job object includes <a class="reference internal" href="api/multijob.job.html#multijob.job.Job.job_id" title="multijob.job.Job.job_id"><code class="xref py py-attr docutils literal"><span class="pre">job_id</span></code></a> and <a class="reference internal" href="api/multijob.job.html#multijob.job.Job.repetition_id" title="multijob.job.Job.repetition_id"><code class="xref py py-attr docutils literal"><span class="pre">repetition_id</span></code></a> properties that can be used here.
The <a class="reference internal" href="api/multijob.job.html#multijob.job.Job.job_id" title="multijob.job.Job.job_id"><code class="xref py py-attr docutils literal"><span class="pre">job_id</span></code></a> identifies the parameter configuration.
If you repeated each configuration, the <code class="docutils literal"><span class="pre">job_id</span></code> is therefore not unique.
Instead, the <a class="reference internal" href="api/multijob.job.html#multijob.job.Job.repetition_id" title="multijob.job.Job.repetition_id"><code class="xref py py-attr docutils literal"><span class="pre">repetition_id</span></code></a> identifies repetitions of the same <code class="docutils literal"><span class="pre">job_id</span></code>.</p>
<p>To create a result file using both of these IDs, you could do:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;results.</span><span class="si">{}</span><span class="s2">.</span><span class="si">{}</span><span class="s2">.csv&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">job_id</span><span class="p">,</span> <span class="n">job</span><span class="o">.</span><span class="n">repetition_id</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This produces file names like <code class="docutils literal"><span class="pre">results.3.7.csv</span></code>.</p>
<p>Of course, Multijob imposes no restrictions on the file name so you can use whatever schema you want, or even use non-file-based solutions like REST APIs or databases.</p>
<p>In my experience, it is best to put all of this plumbing into a separate <code class="docutils literal"><span class="pre">main()</span></code> function. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">multijob.commandline</span> <span class="k">import</span> <span class="n">job_from_argv</span>

<span class="k">def</span> <span class="nf">runGA</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">TYPEMAP</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">argv</span><span class="p">):</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">job_from_argv</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">runGA</span><span class="p">,</span> <span class="n">typemap</span><span class="o">=</span><span class="n">TYPEMAP</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

    <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;results-</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">-logbook.csv&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">job</span><span class="o">.</span><span class="n">job_id</span><span class="p">,</span> <span class="n">job</span><span class="o">.</span><span class="n">repetition_id</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">csv_file</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">result</span><span class="p">:</span>
            <span class="n">csv_file</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</pre></div>
</div>
<p>Now that your actual algorithm has been wrapped as an independent shell script,
you can test it by running the script directly.
Remember that you will have to provide all parameters in the expected format, and that you have to provide a job id:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ python runGA.py --id=0 --rep=0 -- x=7 y=42.3 z=&#39;foo bar&#39;
</pre></div>
</div>
</div>
</div>
<div class="section" id="creating-the-jobs">
<h2>Creating the jobs<a class="headerlink" href="#creating-the-jobs" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="api/multijob.job.html#multijob.job.JobBuilder" title="multijob.job.JobBuilder"><code class="xref py py-class docutils literal"><span class="pre">multijob.job.JobBuilder</span></code></a> is used to generate all job configurations you want to run.
For each parameter, you can specify a list of one or more possible values for this parameter.
The job configurations are then the cartesian product of these lists.</p>
<p>You have multiple possibilities to provide these lists:</p>
<ul class="simple">
<li><a class="reference internal" href="api/multijob.job.html#multijob.job.JobBuilder.add" title="multijob.job.JobBuilder.add"><code class="xref py py-meth docutils literal"><span class="pre">builder.add(name,</span> <span class="pre">*values)</span></code></a>
– explicitly provide the values. Recommended.</li>
<li><a class="reference internal" href="api/multijob.job.html#multijob.job.JobBuilder.add_range" title="multijob.job.JobBuilder.add_range"><code class="xref py py-meth docutils literal"><span class="pre">builder.add_range(name,</span> <span class="pre">start,</span> <span class="pre">stop,</span> <span class="pre">stride)</span></code></a>
– add a list of floats, starting from the <code class="docutils literal"><span class="pre">start</span></code>, where the <code class="docutils literal"><span class="pre">stride</span></code> separates two consecutive numbers.</li>
<li><a class="reference internal" href="api/multijob.job.html#multijob.job.JobBuilder.add_linspace" title="multijob.job.JobBuilder.add_linspace"><code class="xref py py-meth docutils literal"><span class="pre">builder.add_linspace(name,</span> <span class="pre">start,</span> <span class="pre">stop,</span> <span class="pre">n)</span></code></a>
– add a list of <code class="docutils literal"><span class="pre">n</span></code> evenly spaced floats
including the <code class="docutils literal"><span class="pre">start</span></code> and <code class="docutils literal"><span class="pre">stop</span></code>.</li>
</ul>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multijob.job</span> <span class="k">import</span> <span class="n">JobBuilder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">builder</span> <span class="o">=</span> <span class="n">JobBuilder</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">builder</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;explict&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(1, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">builder</span><span class="o">.</span><span class="n">add_range</span><span class="p">(</span><span class="s1">&#39;range&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="go">[0.0, 2.0, 4.0, 6.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">builder</span><span class="o">.</span><span class="n">add_linspace</span><span class="p">(</span><span class="s1">&#39;linspace&#39;</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[3.0, 4.0, 5.0, 6.0]</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">add_range()</span></code> and <code class="docutils literal"><span class="pre">add_linspace()</span></code> variants are only convenience functions.
They have many problematic aspects:</p>
<ul class="simple">
<li>They only operate on floats.
Because floats are inherently imprecise, you may see rounding problems.</li>
<li>Also, their output is evenly spaced.
Your parameters might benefit from a different distribution, e.g. more dense around zero, or selected randomly.
Randomizing your values also prevents sampling artifacts.
If you randomize your values, make sure to record the random generator seed to ensure reproducibility!</li>
</ul>
<p>When you specify many possible parameter values, this easily leads to a combinatorial explosion of job configurations.
You may want to check for a sane number of configurations first.
For that each builder can calculate the expected <code class="xref py py-meth docutils literal"><span class="pre">number_of_jobs()</span></code>.
This only considers the number of distinct configurations that will be built, but does not consider repetitions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">number_of_jobs</span><span class="p">()</span>
<span class="n">max_jobs</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="k">if</span> <span class="n">n_jobs</span> <span class="o">&gt;</span> <span class="n">max_jobs</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
        <span class="s2">&quot;too many job configurations: </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">max_jobs</span><span class="p">))</span>
</pre></div>
</div>
<p>Finally, we generate the actual list of jobs.
Since we want to turn the jobs into shell commands,
these job instances will never be directly run.
We can therefore use a dummy callback for the worker function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dummy</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">jobs</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
</pre></div>
</div>
<p>For many uses, it makes sense to repeat each configuration multiple times.
In the context of evolutionary algorithms, the results of a single run are not statistically significant.
We need multiple repetitions of each configuration in order to draw reliable conclusions.
The <code class="docutils literal"><span class="pre">build()</span></code> method can take a <code class="docutils literal"><span class="pre">repetitions</span></code> argument that specifies the number of repetitions of each config, it defaults to 1.</p>
<p>The repeated job objects are identical (same param values, same job id) except for the repetition ID.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">jobs</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="turning-jobs-into-shell-commands">
<h2>Turning jobs into shell commands<a class="headerlink" href="#turning-jobs-into-shell-commands" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="api/multijob.commandline.html#multijob.commandline.shell_command_from_job" title="multijob.commandline.shell_command_from_job"><code class="xref py py-func docutils literal"><span class="pre">shell_command_from_job(prefix,</span> <span class="pre">job)</span></code></a> function
can turn a <a class="reference internal" href="api/multijob.job.html#multijob.job.Job" title="multijob.job.Job"><code class="xref py py-class docutils literal"><span class="pre">Job</span></code></a> object
into a shell command.
The <code class="docutils literal"><span class="pre">prefix</span></code> argument is the command that should be invoked with the job parameters as arguments.
If you know the command name in advance, you can use it here:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">shell_command_from_job</span><span class="p">(</span><span class="s1">&#39;./target.exe&#39;</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
</pre></div>
</div>
<p>However, choosing a particular target executable is unnecessary at this point.
By using a shell variable, we can defer the decision until run time.
A variable will later make it easier to run distributed jobs on multiple servers.
The variable also allows the same job definition file
to be run with different target executables
(e.g. a <code class="docutils literal"><span class="pre">runGA.py</span></code> script and a <code class="docutils literal"><span class="pre">runGA</span></code> native program).
I recommend using the <code class="docutils literal"><span class="pre">RUN_GA</span></code> variable:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">shell_command_from_job</span><span class="p">(</span><span class="s1">&#39;$RUN_GA&#39;</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, the job parameters are just converted to strings
via the builtin <code class="xref py py-func docutils literal"><span class="pre">str()</span></code>.
If this is not appropriate,
you can provide a typemap to provide an explicit serialization.
This is discussed in more detail above
in the section <a class="reference internal" href="#typemaps-and-coercions">Typemaps and Coercions</a>.</p>
<p>The resulting commands should be written to a file, usually called <code class="docutils literal"><span class="pre">jobs.sh</span></code>.
This happens to be a valid shell script,
though it should be rather understood as a line-by-line list of work items.</p>
<p>You can create this file by just writing to STDOUT and piping the results into a file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multijob.commandline</span> <span class="k">import</span> <span class="n">shell_command_from_job</span>

<span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">shell_command_from_job</span><span class="p">(</span><span class="s1">&#39;$RUN_GA&#39;</span><span class="p">,</span> <span class="n">job</span><span class="p">))</span>
</pre></div>
</div>
<p>Then on the commandline: <code class="docutils literal"><span class="pre">python</span> <span class="pre">generate-jobs.py</span> <span class="pre">&gt;jobs.sh</span></code>.</p>
<p>If your job generation script produces additional output that does not belong into the jobs file, you will have to open a file explicitly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multijob.commandline</span> <span class="k">import</span> <span class="n">shell_command_from_job</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;jobs.sh&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">shell_command_from_job</span><span class="p">(</span><span class="s1">&#39;$RUN_GA&#39;</span><span class="p">,</span> <span class="n">job</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="executing-jobs-locally-with-parallel">
<span id="id1"></span><h2>Executing jobs locally with <code class="docutils literal"><span class="pre">parallel</span></code><a class="headerlink" href="#executing-jobs-locally-with-parallel" title="Permalink to this headline">¶</a></h2>
<p>Running the jobs locally is fairly easy:
We just pipe the <code class="docutils literal"><span class="pre">jobs.sh</span></code> file into <code class="docutils literal"><span class="pre">parallel</span></code>.
This will read the file line by line and execute each line as an individual shell script.
By default, this will try to utilize your CPU optimally, and will run one job per available logical CPU.</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span><span class="c1"># Minimal usage:</span>
$ parallel &lt;jobs.sh
</pre></div>
</div>
<p>However, GNU Parallel provides many additional useful options.
Of these, <code class="docutils literal"><span class="pre">--eta</span></code> and <code class="docutils literal"><span class="pre">joblog</span> <span class="pre">LOGFILE</span></code> are must-have options:</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span><span class="c1"># Recommended usage</span>
$ parallel --eta --joblog .parallel-log &lt;jobs.sh
</pre></div>
</div>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">--eta</span></code></dt>
<dd><p class="first">Prints regular progress information
and tries to estimate the remaining time until completion of all jobs.
The estimates are unreliable until the first batch of jobs has completed.</p>
<p class="last">This option is extremely useful feedback for monitoring,
and for using your intermediate time.
Since the number of completed jobs is slowly going up,
you can see that the experiment is in fact making progress.
If the time estimate is longer than expected,
you may want to schedule the experiment for a time where you are absent,
e.g. over night or over a weekend.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">--jobs</span> <span class="pre">N</span></code></dt>
<dd>Limits the number of parallel jobs.
This is mostly useful for testing where you don&#8217;t want to run with full power.</dd>
<dt><code class="docutils literal"><span class="pre">--joblog</span> <span class="pre">LOGFILE</span></code></dt>
<dd><p class="first">Causes <code class="docutils literal"><span class="pre">parallel</span></code> to keep track of which jobs were started and run.
If the jobs were interrupted (e.g. network connection loss),
they can then be resumed later.</p>
<p>To resume processing, use the exact same set of options
but add the <code class="docutils literal"><span class="pre">--resume</span></code> flag.
This will continue with the next job that wasn&#8217;t run.
In practice, it is probably better to use <code class="docutils literal"><span class="pre">--resume-failed</span></code>
since the cause of interruption will likely cause jobs to fail.
That way, any job that was recorded as completed-but-failed will also be run.</p>
<p class="last">Resuming will only work correctly if the exact same options are used.
This also means that the <code class="docutils literal"><span class="pre">jobs.sh</span></code> file should not be modified.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">--line-buffer</span></code></dt>
<dd><p class="first">Switch buffering mode to line-buffers.</p>
<p>By default (<code class="docutils literal"><span class="pre">--group</span></code>),
the complete output (STDOUT, STDERR) is buffered until that job completes,
and is then printed out at once.
This avoids that the input of multiple jobs is intermingled, but also means that the output is deferred.
This also requires extra storage and processing power.</p>
<p>Depending on your programs, it can be better to switch to line buffering,
or to deactivate output buffering entirely.
With line buffering, each line is printed as soon as it is complete.
That means output arrives sooner, but lines of multiple jobs are intermingled without any indication which line belongs to which job.</p>
<p>You can <code class="docutils literal"><span class="pre">--tag</span></code> the output lines but by default that will prepend all arguments, which is likely to be unreadable.
Instead, consider a custom <code class="docutils literal"><span class="pre">--tagstring</span> <span class="pre">PATTERN</span></code>, e.g. with a pattern like <code class="docutils literal"><span class="pre">&quot;{#}&quot;</span></code>, which would be the GNU Parallel job ID.</p>
<p class="last">To turn buffering off completely, use <code class="docutils literal"><span class="pre">--ungroup</span></code>.</p>
</dd>
</dl>
</div>
<div class="section" id="executing-jobs-remotely-with-parallel">
<h2>Executing jobs remotely with <code class="docutils literal"><span class="pre">parallel</span></code><a class="headerlink" href="#executing-jobs-remotely-with-parallel" title="Permalink to this headline">¶</a></h2>
<p>To run a job on remote servers, we have to tackle two problems:</p>
<ul class="simple">
<li>initialize the necessary environment for the job (data files, tools, libraries)</li>
<li>connect to the server, transfer any files, run the experiment, and transfer results back</li>
</ul>
<div class="section" id="initializing-the-remote-environment">
<h3>Initializing the remote environment<a class="headerlink" href="#initializing-the-remote-environment" title="Permalink to this headline">¶</a></h3>
<p>Because we have to initialize the remote environment first,
we cannot run our target executable <code class="docutils literal"><span class="pre">runGA.py</span></code> directly.
Instead, we&#8217;ll have to create a wrapper script
that initializes the environment
and then runs the actual script.</p>
<p>This <code class="docutils literal"><span class="pre">remote-job.sh</span></code> script will:</p>
<ul class="simple">
<li>unpack any data files that were transferred as an archive</li>
<li>initialize the environment</li>
<li>run the actual command</li>
<li>gather any output files into a results archive</li>
</ul>
<p>The results archive must have a name that is known by GNU Parallel so that it can be transferred back.
To that end, the <code class="docutils literal"><span class="pre">remote-job.sh</span></code> will receive
a sequence ID as one parameter,
and of course the line from <code class="docutils literal"><span class="pre">jobs.sh</span></code> as another argument.
In our script, we&#8217;ll call these <code class="docutils literal"><span class="pre">seq_id</span></code> and <code class="docutils literal"><span class="pre">target_exe</span></code>, respectively.</p>
<p>Unpacking the data may just be a case of un-tarring any data files:</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span>tar xzf data.tar.gz
</pre></div>
</div>
<p>How your environment needs to be initialized depends entirely on your system.
In simple cases, it will suffice to activate a <em>venv</em> Python virtual environment that was pre-installed at a known location on the target server:</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span><span class="nb">source</span> path/to/venv/bin/activate
</pre></div>
</div>
<p>In other cases, you may want to adjust environment variables like <code class="docutils literal"><span class="pre">PATH</span></code>.</p>
<p>To run the job, we need to resolve the <code class="docutils literal"><span class="pre">RUN_GA</span></code> environment variable.
Since the given <code class="docutils literal"><span class="pre">jobs.sh</span></code> line is given to the <code class="docutils literal"><span class="pre">remote-job.sh</span></code> script as a single string, we will need to <code class="docutils literal"><span class="pre">exec</span></code> it.</p>
<p>We should also write any output to a log file, though this not technically necessary.
Using STDOUT is probably easier when debugging a concrete problem,
but a logfile de-clutters possible output.
The correct choice, as always, depends on your circumstances.</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span><span class="nv">RUN_GA</span><span class="o">=</span><span class="s1">&#39;python runGA.py&#39;</span>
<span class="nb">eval</span> <span class="s2">&quot;</span><span class="nv">$target_exe</span><span class="s2"> &gt;logfile_</span><span class="si">${</span><span class="nv">seq_id</span><span class="si">}</span><span class="s2">.txt 2&gt;&amp;1&quot;</span>
</pre></div>
</div>
<p>Finally, we need to pack any output files into the results archive.
This would be the logfile produced above, and any result files.
For example:</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span>tar czf results-<span class="si">${</span><span class="nv">seq_id</span><span class="si">}</span>.tar.gz <span class="se">\</span>
        result_*.csv logfile_*.csv
</pre></div>
</div>
<p>Together, the complete script would like this.
Note that we <code class="docutils literal"><span class="pre">set</span> <span class="pre">-e</span></code> so that the whole script will fail as soon as any command fails.
This fail-fast behaviour makes it more likely that errors will be spotted early, before you spent many hours running a potentially flawed experiment.</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="nb">set</span> -e
<span class="nv">seq_id</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>
<span class="nv">target_exe</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$2</span><span class="s2">&quot;</span>

<span class="c1"># unpack data files</span>
tar xzf data.tar.gz

<span class="c1"># initialize environment</span>
<span class="nb">source</span> path/to/venv/bin/activate

<span class="c1"># run experiment</span>
<span class="nv">RUN_GA</span><span class="o">=</span><span class="s1">&#39;python runGA.py&#39;</span>
<span class="nb">eval</span> <span class="s2">&quot;</span><span class="nv">$target_exe</span><span class="s2"> &gt;logfile_</span><span class="si">${</span><span class="nv">seq_id</span><span class="si">}</span><span class="s2">.txt 2&gt;&amp;1&quot;</span>

<span class="c1"># gather results</span>
tar czf results-<span class="si">${</span><span class="nv">seq_id</span><span class="si">}</span>.tar.gz <span class="se">\</span>
        result_*.csv logfile_*.csv
</pre></div>
</div>
</div>
<div class="section" id="preparing-ssh-connections">
<span id="id2"></span><h3>Preparing SSH connections<a class="headerlink" href="#preparing-ssh-connections" title="Permalink to this headline">¶</a></h3>
<p>GNU Parallel needs to be able to log into the remote servers
without a password.
I.e. the controlling user must upload a public key to the remote servers,
and add the corresponding private key to their keyring session.
See <code class="docutils literal"><span class="pre">ssh-agent</span></code> for info on the keyring.
You can add keys with <code class="docutils literal"><span class="pre">ssh-add</span></code>.</p>
<p>By default, there will be
one SSH connection per available CPU to each remote host.
Usually, the SSH server has a fairly low connection limit
which can cause some GNU Parallel connections to be refused.
For large servers,
you will have to edit the <em>sshd</em> configuration to raise the limit.
At the very least, you will need to allow as many connections as you have CPUs,
plus at least two additional connections.</p>
<p>We can later list all remote hosts on the commandline,
or store them in an <code class="docutils literal"><span class="pre">--sshloginfile</span></code>.
This text file contains one hostname per line,
plus additional flags e.g. to limit the number of concurrent jobs on that host.</p>
</div>
<div class="section" id="running-the-remote-job">
<h3>Running the remote job<a class="headerlink" href="#running-the-remote-job" title="Permalink to this headline">¶</a></h3>
<p>We now need to transfer all these files to the server and run them.
This implies the various options for running the script locally,
as explained in section <a class="reference internal" href="#executing-jobs-locally-with-parallel"><span class="std std-ref">Executing jobs locally with parallel</span></a>.</p>
<p>Instead of running the target executable directly,
we want to actually run the wrapper script on the server:</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span>$ parallel OPTIONS... ./remote-job.sh <span class="s1">&#39;{#}&#39;</span> <span class="s1">&#39;{}&#39;</span> &lt;jobs.sh
</pre></div>
</div>
<p>The placeholders <code class="docutils literal"><span class="pre">{#}</span></code> and <code class="docutils literal"><span class="pre">{}</span></code> will be replaced by GNU Parallel
to provide the actual arguments.
The <code class="docutils literal"><span class="pre">{#}</span></code> is the GNU Parallel job id,
which is used as <cite>seq_id</cite> in the script.
The <code class="docutils literal"><span class="pre">{}</span></code> is one line from the <code class="docutils literal"><span class="pre">jobs.sh</span></code> file,
i.e. the job configuration as a shell script snippet.</p>
<p>Required options:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">--workdir</span> <span class="pre">DIRECTORY</span></code></dt>
<dd><p class="first">The job will be executed in some particular <code class="docutils literal"><span class="pre">--workdir</span></code>.</p>
<p>You can specify a path to a directory,
but then all concurrent jobs will share this directory.
If you write your <code class="docutils literal"><span class="pre">remote-job.sh</span></code> to reflect this,
a pre-configured path can be OK.
E.g. the <code class="docutils literal"><span class="pre">remote-job.sh</span></code> could use the <code class="docutils literal"><span class="pre">seq_id</span></code>
to create a temporary subdir.
The advantage of a known directory is that
any data files only need to be transferred once,
and that you can pre-configure the environment.</p>
<p class="last">This complication is usually undesirable,
so we can get a temporary directory by giving GNU Parallel a triple dot:
<code class="docutils literal"><span class="pre">--workdir</span> <span class="pre">...</span></code>.
However, now all files have to be transferred again for each job,
or manually before the experiment to a known location on the server.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">--transferfile</span> <span class="pre">FILE</span></code></dt>
<dd><p class="first">Files that should be transferred to the remote host for each job
are given with <code class="docutils literal"><span class="pre">--transferfile</span></code>.
In particular, this is
the data archive <code class="docutils literal"><span class="pre">data.tar.gz</span></code>,
the <code class="docutils literal"><span class="pre">remote-job.sh</span></code> script, and
the target executable (e.g. <code class="docutils literal"><span class="pre">runGA.py</span></code>).
This option is repeated for each file:</p>
<div class="last highlight-sh"><div class="highlight"><pre><span></span>parallel OPTIONS... <span class="se">\</span>
    --transferfile data.tar.gz <span class="se">\</span>
    --transferfile remote-job.sh <span class="se">\</span>
    --transferfile runGA.py <span class="se">\</span>
    COMMAND ARGS...
</pre></div>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">--return</span> <span class="pre">FILE</span></code></dt>
<dd>Files that should be returned from the remote server
have to be listed with <code class="docutils literal"><span class="pre">--return</span></code>.
In our case, this would be the result archive <code class="docutils literal"><span class="pre">results-${seq_id}.tar.gz</span></code>.
To generate the correct name with the ID,
GNU Parallel can perform a substitution:
<code class="docutils literal"><span class="pre">--return</span> <span class="pre">'results-{#}.tar.gz'</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">--cleanup</span></code></dt>
<dd>Any transferred files and the temporary directory
should be deleted afterwards.</dd>
<dt><code class="docutils literal"><span class="pre">--sshlogin</span> <span class="pre">HOST</span></code>, <code class="docutils literal"><span class="pre">--sshloginfile</span> <span class="pre">FILE</span></code></dt>
<dd>A list of remote hosts.
The <code class="docutils literal"><span class="pre">--sshlogin</span></code> option is repeated for each remote host.
See the section <a class="reference internal" href="#preparing-ssh-connections"><span class="std std-ref">Preparing SSH connections</span></a> for details.</dd>
</dl>
<p>After collecting the data files,
these options allow you to run the jobs remotely.
Afterwards, we can unpack the result archives and perform any analysis:</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span><span class="c1"># Create the data archive</span>
tar czf data.tar.gz data/

<span class="c1"># Run the job remotely</span>
parallel                            <span class="se">\</span>
    --hostname worker.example.com   <span class="se">\</span>
    --workdir ...                   <span class="se">\</span>
    --transferfile data.tar.gz      <span class="se">\</span>
    --transferfile remote-job.sh    <span class="se">\</span>
    --transferfile runGA.py         <span class="se">\</span>
    --return <span class="s1">&#39;result-{#}.tar.gz&#39;</span>    <span class="se">\</span>
    --cleanup                       <span class="se">\</span>
    --eta                           <span class="se">\</span>
    --joblog .joblog                <span class="se">\</span>
    ./remote-job.sh <span class="s1">&#39;{#}&#39;</span> <span class="s1">&#39;{}&#39;</span> &lt;jobs.sh

<span class="c1"># Unpack the results</span>
parallel tar xzf ::: result-*.tar.gz

<span class="c1"># Clean unneeded files</span>
rm -f data.tar.gz result-*.tar.gz
</pre></div>
</div>
<p>And that&#8217;s it!
This looks like a lot,
but you probably only need half the details mentioned here,
and everything will be easier the second time.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Multijob</a></h1>









  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">From scripts to GNU Parallel</a><ul>
<li><a class="reference internal" href="#concepts-and-architecture">Concepts and Architecture</a></li>
<li><a class="reference internal" href="#typemaps-and-coercions">Typemaps and Coercions</a></li>
<li><a class="reference internal" href="#converting-a-runga-function-to-a-runga-py-script">Converting a <code class="docutils literal"><span class="pre">runGA()</span></code> function to a <code class="docutils literal"><span class="pre">runGA.py</span></code> script</a><ul>
<li><a class="reference internal" href="#creating-a-typemap-to-decode-command-line-args">Creating a Typemap to decode command line args</a></li>
<li><a class="reference internal" href="#decoding-and-running-the-job">Decoding and running the Job</a></li>
<li><a class="reference internal" href="#storing-results-in-a-file">Storing results in a file</a></li>
</ul>
</li>
<li><a class="reference internal" href="#creating-the-jobs">Creating the jobs</a></li>
<li><a class="reference internal" href="#turning-jobs-into-shell-commands">Turning jobs into shell commands</a></li>
<li><a class="reference internal" href="#executing-jobs-locally-with-parallel">Executing jobs locally with <code class="docutils literal"><span class="pre">parallel</span></code></a></li>
<li><a class="reference internal" href="#executing-jobs-remotely-with-parallel">Executing jobs remotely with <code class="docutils literal"><span class="pre">parallel</span></code></a><ul>
<li><a class="reference internal" href="#initializing-the-remote-environment">Initializing the remote environment</a></li>
<li><a class="reference internal" href="#preparing-ssh-connections">Preparing SSH connections</a></li>
<li><a class="reference internal" href="#running-the-remote-job">Running the remote job</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api/multijob.html">multijob package</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">From scripts to GNU Parallel</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="api/multijob.job.html" title="previous chapter">multijob.job module</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, the Multijob authors.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/parallelTutorial.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>